

#' Compare multiple alpha diversity indexes between groups
#'
#' This function calculates average of alpha diversity indexes for a specific rarefaction depth, standardize diversity indexes and compare between groups
#' using linear/linear mixed effect model and adjust for covariates.
#' @param datlist the list of your dataframe.
#' @param depth the rarefaction depth of choice. Depth can be "max" (highest depth) or an order (number) of the depth in the list generated by alpha_rarefaction.py
#' @param mapfile mapping file
#' @param mapsampleid sample id in the mapping file
#' @param comvar variable for comparison
#' @param adjustvar variables that need to be adjusted in the model
#' @param personid name of variable for person id. Default is "personid" (applicable when longitudinal="yes").
#' @param longitudinal longitudinal data or one time data. Options are c("yes","no"). Default is "yes".
#' @param age.limit age upper limit for included samples. Default is 1000000 months (~no upper limit).
#' @param standardize standardization of diversity indexes before comparison or not. Default is FALSE.
#' @return list of comparison result matrices and mean diversity of all indexes for each samples (with or without standardization)
#' @keywords alpha diversity comparison
#' @export
#' @examples
#' #Read in outputs from "alpha_rarefaction.py" in QIIME
#' patht<-system.file("extdata/QIIME_outputs/Bangladesh/alpha_div_collated", package = "metamicrobiomeR", mustWork = TRUE)
#' alpha.rm<-read.multi(patht=patht,patternt=".txt",assignt="no",study="Bangladesh")
#' #Bangladesh extra metadata
#' data(sam.rm)
#' samfile<-merge(samde, he50[,c("child.id","gender","month.exbf","month.food")],by="child.id")
#' samfile$age.sample<-samfile$age.months
#' samfile$bf<-factor(samfile$bf,levels=c("ExclusiveBF","Non_exclusiveBF","No_BF"))
#' samfile$personid<-samfile$child.id
#' samfile$sampleid<-tolower(samfile$fecal.sample.id)
#' #comparison of standardized alpha diversity indexes between genders adjusting for breastfeeding and infant age at sample collection in infants <=6 months of age
#' alphacom6.rm.sexsg<-alpha.compare(datlist=alpha.rm,depth=3,mapfile=samfile,mapsampleid="fecal.sample.id",comvar="gender",adjustvar=c("age.sample","bf"),longitudinal="yes",age.limit=6,standardize=TRUE)
#' alphacom6.rm.sexsg$alphasum[,1:5]


# Function to compare alpha diversity between groups
alpha.compare <- function(datlist, depth, mapfile, mapsampleid, comvar, adjustvar, personid = "personid", longitudinal = "yes", age.limit = 1000000, standardize = FALSE, ...) {

  # Load required packages
  #sapply(c("lme4", "lmerTest", "plyr", "dplyr", "reshape2"), require, character.only = TRUE)

  # Create empty matrices to store results
  alphamean <- matrix(NA, nrow = length(names(datlist)), ncol = (ncol(datlist[[1]]) - 3))
  rownames(alphamean) <- names(datlist)
  colnames(alphamean) <- colnames(datlist[[1]])[-c(1:3)]

  # Loop over data lists
  for (i in 1:length(names(datlist))) {

    # Get data for current group
    dat.a <- datlist[[i]]

    # Get rarefaction depth
    raredepth <- unique(dat.a$sequences.per.sample)[as.numeric(as.character(depth))]
    if (depth == "max") {
      raredepth <- max(unique(dat.a$sequences.per.sample))
    }

    # Convert columns to characters and then to numeric
    dat.a[, -c(1:3)] <- lapply(dat.a[, -c(1:3)], as.character)
    dat.a[, -c(1:3)] <- lapply(dat.a[, -c(1:3)], as.numeric)

    # Calculate mean alpha diversity for each rarefaction depth
    dat.mean <- plyr::ddply(dat.a, plyr::.(sequences.per.sample), plyr::colwise(mean))
    alphamean[i, ] <- matrix(unlist(dat.mean[dat.mean$sequences.per.sample == raredepth, -c(1:3)]), nrow = 1)
  }

  # Convert alphamean to data frame
  alphamean <- as.data.frame(t(alphamean))

  # Remove added x from sample names that start with a number
  alphamean$sampleid <- sub('.*x', '', rownames(alphamean))

  # Standardize alpha diversity
  if (standardize == TRUE) {
    alphameans <- dplyr::mutate_at(alphamean, .vars = names(datlist), .funs = function(x) {
      (x - mean(x, na.rm = T)) / sd(x, na.rm = T)
    })
  }

  # Convert mapfile column to lowercase
  mapfile[, mapsampleid] <- tolower(mapfile[, mapsampleid])

  # Get samples that are in both alphamean and mapfile
  alphamean <- alphamean[alphamean$sampleid %in% mapfile[, mapsampleid], ]
  if (standardize == TRUE) {
    alphameans <- alphameans[alphameans$sampleid %in% mapfile[, mapsampleid], ]
  }

  # Merge alphamean with mapfile
  alphamap <- merge(mapfile, alphamean, by.x = mapsampleid, by.y = "sampleid")

  # Apply age limit for comparison
  mapfile <- mapfile[mapfile$age.sample <= age.limit, ]

  # If longitudinal = yes, factor personid column
  if (longitudinal == "yes") {
    alphamap$personid <- as.factor(alphamap[, personid])
  }

  # Create empty list to store results
  alphasum <- NULL

  # Loop over variables
  for (j in 1:length(names(datlist))) {

    # If longitudinal = yes, fit mixed model
    if (longitudinal == "yes") {
      fitsum <- try(summary(lme4::glmer(as.formula(paste(names(datlist)[j], paste(c(comvar, adjustvar,"(1|personid)"),collapse="+"),sep="~")), data=alphamap,family=gaussian(link="identity"))))
    }
	# If longitudinal = no, fit linear model
    } else if (longitudinal == "no") {
      fitsum <- try(summary(glm(as.formula(paste(names(datlist)[j], paste(c(comvar, adjustvar), collapse = "+"), sep = "~")), data = alphamap, family = "gaussian")))
    }

    # If fit failed, print error message and return NA
    if (class(fitsum) == "try-error") {
      cat("Error in model fit, NA introduced.\n")
      fitcoefw <- NULL
      alphasum <- plyr::rbind.fill(alphasum, fitcoefw)
    } else {

      # Extract coefficients and add column names
      fitcoef <- as.data.frame(fitsum$coefficients[rownames(fitsum$coefficients) != "(Intercept)", ])
      fitcoef$varname <- rownames(fitcoef)
      fitcoef$id <- names(datlist)[j]

      # If longitudinal = yes, add p-values
      if (longitudinal == "yes") {
        fitcoef$Pr(>|t|) <- 2 * pnorm(-abs(fitcoef$Estimate / fitcoef$Std. Error))
      }

      # Reshape coefficients into wide format
      fitcoefw <- reshape(fitcoef, idvar = "id", timevar = "varname", direction = "wide")

      # Add fitcoefw to alphasum
      alphasum <- plyr::rbind.fill(alphasum, fitcoefw)
    }
  }

  # If standardize = yes, return list of alphamean, alphamean.standardized, and alphasum
  if (standardize == TRUE) {
    return(list(alphamean = alphamean, alphamean.standardized = alphameans, alphasum = alphasum))
  } else {
    return(list(alphamean = alphamean, alphasum = alphasum))
  }
}
